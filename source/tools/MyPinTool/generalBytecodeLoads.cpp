#define PIN_DEPRECATED_WARNINGS 0
#include <stdio.h>
#include <map>
#include <iostream>
#include <fstream>
#include <fcntl.h>
#include <vector>
#include <deque>
#include <set>
#include <inttypes.h>
#include <chrono>
#include <queue>
#include "pin.H"

using std::string;
using std::map;
using std::ofstream; 
using std::ios;

ofstream OutFile;
ofstream DebugFile;

// Name of output file
KNOB <string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "first_tool.out", "output file");
KNOB <string> KnobDebugFile(KNOB_MODE_WRITEONCE, "pintool", "d", "tool_debug.out", "debug file");

// Addresses used for 
ADDRINT mainModuleBase = 0;
ADDRINT mainModuleHigh = 0;

// Callback for loaded images - to find the base and high of the program, and thus calculate offsets
VOID Image(IMG img, VOID* v) {
    if (IMG_IsMainExecutable(img)) {
        mainModuleBase = IMG_LowAddress(img);
        mainModuleHigh = IMG_HighAddress(img);
    }
}

// Generated by ChatGPT
bool registersAreOverlapping(const std::string& reg1, const std::string& reg2) {
    static const std::map<std::string, std::string> regMap = {
        // RAX register family
        {"rax", "rax"}, {"eax", "rax"}, {"ax", "rax"}, {"al", "rax"}, {"ah", "rax"},
        // RBX register family
        {"rbx", "rbx"}, {"ebx", "rbx"}, {"bx", "rbx"}, {"bl", "rbx"}, {"bh", "rbx"},
        // RCX register family
        {"rcx", "rcx"}, {"ecx", "rcx"}, {"cx", "rcx"}, {"cl", "rcx"}, {"ch", "rcx"},
        // RDX register family
        {"rdx", "rdx"}, {"edx", "rdx"}, {"dx", "rdx"}, {"dl", "rdx"}, {"dh", "rdx"},
        // RSI register family
        {"rsi", "rsi"}, {"esi", "rsi"}, {"si", "rsi"}, {"sil", "rsi"},
        // RDI register family
        {"rdi", "rdi"}, {"edi", "rdi"}, {"di", "rdi"}, {"dil", "rdi"},
        // RBP register family
        {"rbp", "rbp"}, {"ebp", "rbp"}, {"bp", "rbp"}, {"bpl", "rbp"},
        // RSP register family
        {"rsp", "rsp"}, {"esp", "rsp"}, {"sp", "rsp"}, {"spl", "rsp"},
        // R8 register family
        {"r8", "r8"}, {"r8d", "r8"}, {"r8w", "r8"}, {"r8b", "r8"},
        // R9 register family
        {"r9", "r9"}, {"r9d", "r9"}, {"r9w", "r9"}, {"r9b", "r9"},
        // R10 register family
        {"r10", "r10"}, {"r10d", "r10"}, {"r10w", "r10"}, {"r10b", "r10"},
        // R11 register family
        {"r11", "r11"}, {"r11d", "r11"}, {"r11w", "r11"}, {"r11b", "r11"},
        // R12 register family
        {"r12", "r12"}, {"r12d", "r12"}, {"r12w", "r12"}, {"r12b", "r12"},
        // R13 register family
        {"r13", "r13"}, {"r13d", "r13"}, {"r13w", "r13"}, {"r13b", "r13"},
        // R14 register family
        {"r14", "r14"}, {"r14d", "r14"}, {"r14w", "r14"}, {"r14b", "r14"},
        // R15 register family
        {"r15", "r15"}, {"r15d", "r15"}, {"r15w", "r15"}, {"r15b", "r15"}
    };
    
    // Find the full 64-bit counterparts for each register
    auto it1 = regMap.find(reg1);
    auto it2 = regMap.find(reg2);

    // If both registers are found, check if they map to the same 64-bit register
    if (it1 != regMap.end() && it2 != regMap.end()) {
        return it1->second == it2->second;
    }

    // If one of the registers is not found, return false (you might want to handle this differently)
    return false;
}

struct REGS_STRINGS {
    string READ_REGS[3];
    string WRITE_REGS[3];
};

struct INS_WITH_REGS {
    ADDRINT INS_ADDR;
    string SOURCE_REGS[3];
    string DEST_REGS[3];
    bool IS_MEMORY_READ;
    ADDRINT MEMORY_ADDR = 0L;
};


struct PossibleTableLoadIns {
    ADDRINT PC;
    ADDRINT LOADED_ADDR;
    string READ_REGS[3];
    string WRITE_REGS[3];
};

struct TableLoadIns {
    ADDRINT LOAD_INDEX_ADDR;
    ADDRINT LOAD_TABLE_ADDR;
    ADDRINT JMP_ADDR;
    ADDRINT LOAD_INDEX_MEMORY_EA;
    string READ_REGS[3];
    string WRITE_REGS[3];
};
constexpr bool operator< ( TableLoadIns const& a, TableLoadIns const& b)
    { return std::make_pair(a.LOAD_TABLE_ADDR, a.JMP_ADDR) < std::make_pair(b.LOAD_TABLE_ADDR, b.JMP_ADDR); }

void copyRegs(PossibleTableLoadIns &tableLoad, REGS_STRINGS const* regs) {
    for (int i = 0; i < 3; i++) {
        tableLoad.READ_REGS[i] = regs->READ_REGS[i]; 
        tableLoad.WRITE_REGS[i] = regs->WRITE_REGS[i];
    } 
}

void printRegs(REGS_STRINGS const* regs) {
    std::cout << "Read regs: ";
    for (const string &str : regs->READ_REGS) {
        std::cout << str << " ";
    }
    std::cout << "Write regs: ";
    for (const string &str : regs->WRITE_REGS) {
        std::cout << str << " ";
    }
    std::cout << "\n";
}

void copyRegs(TableLoadIns &tableLoad, PossibleTableLoadIns const* possibleTableLoad) {
    for (int i = 0; i < 3; i++) {
        tableLoad.READ_REGS[i] = possibleTableLoad->READ_REGS[i]; 
        tableLoad.WRITE_REGS[i] = possibleTableLoad->WRITE_REGS[i];
    } 
}  

void copyRegs(INS_WITH_REGS &ins, REGS_STRINGS const* regs) {
    for (int i = 0; i < 3; i++) {
        ins.SOURCE_REGS[i] = regs->READ_REGS[i]; 
        ins.DEST_REGS[i] = regs->WRITE_REGS[i];
    } 
}  

std::vector<TableLoadIns> tableLoadInstructions;
std::set<ADDRINT> indirectJumps;

int tableLoadIndex = 0;
constexpr int SIZE_OF_POSSIBLETABLELOADS = 50;
std::vector<PossibleTableLoadIns> possibleTableLoadInsVector;

int insBufferIndex = 0;
constexpr int SIZE_OF_INS_BUFFER = 500;
std::vector<INS_WITH_REGS> instructionBuffer;

VOID addToInstructionBuffer(ADDRINT PC, REGS_STRINGS* regs, BOOL memoryLoad, ADDRINT memoryEA) {
    INS_WITH_REGS ins;
    copyRegs(ins, regs);
    ins.IS_MEMORY_READ = memoryLoad;
    ins.INS_ADDR = PC;
    if (memoryLoad) ins.MEMORY_ADDR = memoryEA; 

    if (instructionBuffer.size() < SIZE_OF_INS_BUFFER) {
        instructionBuffer.push_back(ins);
    } else {
        instructionBuffer[insBufferIndex] = ins;
    }
    insBufferIndex++;
    if (insBufferIndex == SIZE_OF_INS_BUFFER) insBufferIndex = 0;
}

VOID memoryLoad(ADDRINT PC, ADDRINT readAddr, UINT32 readSize, REGS_STRINGS* regs) {
    PossibleTableLoadIns loadIns;

    addToInstructionBuffer(PC, regs, true, readAddr);

    if (readSize == 8){
         UINT64 readValue;
        if (regs->READ_REGS[1] == "") return;
        // Safely read the memory content
        if (PIN_SafeCopy(&readValue, reinterpret_cast<void*>(readAddr), readSize) == readSize) {
            // Print the memory read value in hex
            loadIns.PC = PC - mainModuleBase;
            loadIns.LOADED_ADDR =  static_cast<ADDRINT>(readValue) - mainModuleBase;
            copyRegs(loadIns, regs);
            if (possibleTableLoadInsVector.size() < SIZE_OF_POSSIBLETABLELOADS) {
                possibleTableLoadInsVector.push_back(loadIns);
            } else {
                possibleTableLoadInsVector[tableLoadIndex] = loadIns;
            }
            tableLoadIndex++;
            if (tableLoadIndex == SIZE_OF_POSSIBLETABLELOADS) tableLoadIndex = 0;
        } else {
            std::cout << "Failed to read memory at address " << std::hex << readAddr << std::endl;
        }
    } else if (readSize == 4) {
        UINT32 readValue;
        if (regs->READ_REGS[1] == "") return;
        // Safely read the memory content
        if (PIN_SafeCopy(&readValue, reinterpret_cast<void*>(readAddr), readSize) == readSize) {
            // Print the memory read value in hex
            loadIns.PC = PC - mainModuleBase;
            loadIns.LOADED_ADDR =  static_cast<ADDRINT>(readValue) - mainModuleBase;
            copyRegs(loadIns, regs);
            if (possibleTableLoadInsVector.size() < SIZE_OF_POSSIBLETABLELOADS) {
                possibleTableLoadInsVector.push_back(loadIns);
            } else {
                possibleTableLoadInsVector[tableLoadIndex] = loadIns;
            }
            tableLoadIndex++;
            if (tableLoadIndex == SIZE_OF_POSSIBLETABLELOADS) tableLoadIndex = 0;
        } else {
            std::cout << "Failed to read memory at address " << std::hex << readAddr << std::endl;
        }
    }
   
}

VOID trackBackToFindSource(TableLoadIns& tableLoadIns) {
    string currReg = tableLoadIns.READ_REGS[1];
    std::vector<std::pair<string, ADDRINT>> trace;
    trace.push_back(std::make_pair(currReg, tableLoadIns.LOAD_TABLE_ADDR));
    int startingIndex = 0;
    
    for (int i = 0; i < SIZE_OF_INS_BUFFER; i++) { 
        startingIndex = i + 1;
        INS_WITH_REGS curr_ins;
        if (insBufferIndex - i >= 0) curr_ins = instructionBuffer[insBufferIndex - i];
        else instructionBuffer[SIZE_OF_INS_BUFFER - (insBufferIndex - i)];
        if (curr_ins.INS_ADDR - mainModuleBase == tableLoadIns.LOAD_TABLE_ADDR) break;
    }

    for (int i = startingIndex; i < SIZE_OF_INS_BUFFER; i++) {
        INS_WITH_REGS curr_ins;
        if (insBufferIndex - i >= 0) curr_ins = instructionBuffer[insBufferIndex - i];
        else instructionBuffer[SIZE_OF_INS_BUFFER - (insBufferIndex - i)];
        
/*         if ((curr_ins.INS_ADDR - mainModuleBase) == 0x2503c3) {
            std::cout << "FOUND 2! " << currReg << " sourceRegs " << curr_ins.SOURCE_REGS[0] << " DestRegs: " << curr_ins.DEST_REGS[0] << "\n";
        }
        if ((curr_ins.INS_ADDR - mainModuleBase) == 0x2503c1) {
            std::cout << "FOUND 1! Trace: ";
            for (const auto &[reg, addr] : trace) {
                 std::cout << reg << " Addr: " << std::hex << addr << " "; 
            }
            std::cout << "\n"; 
        } */
        

        if (registersAreOverlapping(curr_ins.DEST_REGS[0], currReg) 
            || registersAreOverlapping(curr_ins.DEST_REGS[1], currReg) 
            || registersAreOverlapping(curr_ins.DEST_REGS[2], currReg)) {
            //std::cout << "Current REG: " << currReg << " newReg: " << curr_ins.SOURCE_REGS[0] << "\n";
            tableLoadIns.LOAD_INDEX_ADDR = curr_ins.INS_ADDR - mainModuleBase;
            if (curr_ins.IS_MEMORY_READ) {
                tableLoadIns.LOAD_INDEX_MEMORY_EA = curr_ins.MEMORY_ADDR;
                for (std::pair<string, ADDRINT> pair : trace) {
                    DebugFile << std::hex << pair.second << " "; 
                    DebugFile << pair.first << " ";
                }
                DebugFile << "\n";
                return;
            } 
            if (curr_ins.SOURCE_REGS[2] != "" || curr_ins.DEST_REGS[2] != "") {
                DebugFile << "Problem! " << std::hex << curr_ins.INS_ADDR - mainModuleBase << "\n";
            }
            if (curr_ins.SOURCE_REGS[0] != curr_ins.DEST_REGS[0]) currReg = curr_ins.SOURCE_REGS[0];
            else currReg = curr_ins.SOURCE_REGS[1];
            trace.push_back(std::make_pair(currReg, curr_ins.INS_ADDR - mainModuleBase));
        }
    }
    tableLoadIns.LOAD_INDEX_ADDR = 0x999999999;
}


VOID indirectJump(ADDRINT insAddress, ADDRINT targetAddr) {
    auto loadIns = std::find_if(possibleTableLoadInsVector.begin(), possibleTableLoadInsVector.end(),
                                [targetAddr] (const PossibleTableLoadIns possibleTableLoad) {
                                    return possibleTableLoad.LOADED_ADDR == targetAddr - mainModuleBase;
                                });

    if (loadIns != possibleTableLoadInsVector.end()) {
        TableLoadIns tableLoadIns;
        tableLoadIns.LOAD_TABLE_ADDR = loadIns->PC;
        tableLoadIns.JMP_ADDR = insAddress - mainModuleBase;
        for (int i = 0; i < 3; i++) {
            tableLoadIns.READ_REGS[i] = loadIns->READ_REGS[i]; 
            tableLoadIns.WRITE_REGS[i] = loadIns->WRITE_REGS[i]; 
        } 
        trackBackToFindSource(tableLoadIns);
        tableLoadInstructions.push_back(tableLoadIns);
        possibleTableLoadInsVector.clear();
        if (tableLoadIns.LOAD_INDEX_ADDR != 0x999999999) OutFile << std::hex << tableLoadIns.LOAD_INDEX_MEMORY_EA << "\n";
    }
    indirectJumps.insert(insAddress - mainModuleBase); 
}


VOID Instruction(INS ins, VOID* v) {
    // Ensure the instruction is from the main module
    if (INS_Address(ins) >= mainModuleBase && INS_Address(ins) <= mainModuleHigh) {          
        REGS_STRINGS* reg_strings = new REGS_STRINGS;
        if (INS_IsMemoryRead(ins)) {
            size_t numWriteRegs = INS_MaxNumWRegs(ins);
            string writeRegs[3];
            for (size_t i = 0; i < numWriteRegs; ++i) {
                reg_strings->WRITE_REGS[i] = REG_StringShort(INS_RegW(ins, i));
            }
            size_t numReadRegs = INS_MaxNumRRegs(ins);
            string readRegs[3];
            for (size_t i = 0; i < numReadRegs; ++i) {
                reg_strings->READ_REGS[i] = REG_StringShort(INS_RegR(ins, i));
            }

            INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) memoryLoad,
                IARG_INST_PTR,
                IARG_MEMORYREAD_EA,
                IARG_UINT32, INS_MemoryReadSize(ins),
                IARG_PTR, reg_strings,
                IARG_END
            );
        }
        else if (INS_IsIndirectBranchOrCall(ins)){
            delete reg_strings;
            if (!INS_IsCall(ins))INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)indirectJump, IARG_INST_PTR, IARG_BRANCH_TARGET_ADDR, IARG_END);
        }
        else {
            size_t numWriteRegs = INS_MaxNumWRegs(ins);
            string writeRegs[3];
            for (size_t i = 0; i < numWriteRegs; ++i) {
                reg_strings->WRITE_REGS[i] = REG_StringShort(INS_RegW(ins, i));
            }
            size_t numReadRegs = INS_MaxNumRRegs(ins);
            string readRegs[3];
            for (size_t i = 0; i < numReadRegs; ++i) {
                reg_strings->READ_REGS[i] = REG_StringShort(INS_RegR(ins, i));
            }

            if (reg_strings->READ_REGS[0] == "" || reg_strings->WRITE_REGS[0] == "") delete reg_strings;
            else {
                bool memoryRead = false;
                INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR) addToInstructionBuffer,
                    IARG_INST_PTR,
                    IARG_PTR, reg_strings,
                    IARG_BOOL, memoryRead,
                    IARG_UINT64, 0x0,
                    IARG_END
                );
            }
        }
    }
}


VOID Fini(INT32 code, VOID* v) {        
    std::cout << "Time to generate results!" << std::endl;
    DebugFile.setf(ios::showbase);
    DebugFile << "Number of bytecodes seen: " << std::dec << tableLoadInstructions.size() << "\n"; 
/*     DebugFile << "Number of bytecodes correctly located: " << std::dec 
        << (int) std::count_if(tableLoadInstructions.begin(), 
        tableLoadInstructions.end(), [](const TableLoadIns tableLoad) {
            return tableLoad.LOAD_INDEX_ADDR != 0x999999999; }
        ) << "\n";   */
 
/*     for (const auto &tableLoadAddr  : tableLoadInstructions) {
        DebugFile << std::hex << "LoadAddr: " << tableLoadAddr.LOAD_TABLE_ADDR << " JmpAddr: " << tableLoadAddr.JMP_ADDR << " INDEX FROM: " << tableLoadAddr.LOAD_INDEX_ADDR << " Readregs: ";
        for (const string &readReg : tableLoadAddr.READ_REGS) {
            DebugFile << readReg << " ";
        } 
        DebugFile << " WriteRegs: ";
        for (const string &writeReg : tableLoadAddr.WRITE_REGS) {
            DebugFile << writeReg << " ";
        } 
    } */
    DebugFile << "\n\n\n\n";
    DebugFile.close();
}

// Print Help Message
INT32 Usage() {
    std::cerr << "This tool is used to label memory loads which are connected to bytecode loads (for CPython 3.11)" << std::endl;
    std::cerr << std::endl << KNOB_BASE::StringKnobSummary() << std::endl;
    return -1;
}

int main(int argc, char* argv[]) {
    if (PIN_Init(argc, argv)) return Usage();
    
    OutFile.open(KnobOutputFile.Value().c_str());
    DebugFile.open(KnobDebugFile.Value().c_str());
    OutFile.setf(ios::showbase);
    DebugFile.setf(ios::showbase);

    // Fix base adress to enable calculation of offset
    IMG_AddInstrumentFunction(Image, 0);

    std::printf("Starting PinTool! \n");
    INS_AddInstrumentFunction(Instruction, 0);
    PIN_AddFiniFunction(Fini, 0);
    PIN_StartProgram();

    return 0;
}